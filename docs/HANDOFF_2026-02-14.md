# MT7927/MT6639 WiFi 7 PCIe Linux Driver — 完整交接文档

**日期**: 2026-02-14
**用途**: 新上下文窗口接手开发用
**作者**: Claude Code (跨 ~15 个上下文窗口的累积知识)

---

## 目录

1. [项目概述与快速开始](#1-项目概述与快速开始)
2. [当前进度总结](#2-当前进度总结)
3. [已实现的功能](#3-已实现的功能)
4. [当前阻塞问题](#4-当前阻塞问题)
5. [已排除的假设（30+个）](#5-已排除的假设)
6. [代码架构与关键函数](#6-代码架构与关键函数)
7. [硬件寄存器地图](#7-硬件寄存器地图)
8. [思考数据与分析过程](#8-思考数据与分析过程)
9. [下一步方向](#9-下一步方向)
10. [参考代码指南](#10-参考代码指南)
11. [操作手册](#11-操作手册)
12. [致命陷阱清单](#12-致命陷阱清单)

---

## 1. 项目概述与快速开始

### 1.1 项目目标

为 MediaTek MT7927 WiFi 7 PCIe 网卡（内部芯片名 MT6639，CONNAC3X 架构）开发 Linux 内核驱动。

### 1.2 关键信息

| 项 | 值 |
|---|---|
| PCI ID | `14c3:6639` |
| 芯片架构 | CONNAC3X (MT6639) |
| 驱动文件 | `tests/04_risky_ops/mt7927_init_dma.c` (单文件, ~4621行) |
| 构建命令 | `make tests` |
| sudo 密码 | `123456` |
| 固件文件 | `mediatek/WIFI_RAM_CODE_MT6639_2_1.bin` + `mediatek/WIFI_MT6639_PATCH_MCU_2_1_hdr.bin` |
| PCIe 插槽 | `0000:09:00.0` (可能因系统不同) |

### 1.3 快速开始（30 秒上手）

```bash
# 构建
cd /home/user/mt7927 && make tests

# 卸载旧模块
echo 123456 | sudo -S rmmod mt7927_init_dma 2>/dev/null

# 加载模块
echo 123456 | sudo -S insmod tests/04_risky_ops/mt7927_init_dma.ko

# 查看日志（关键行）
echo 123456 | sudo -S dmesg | tail -200 | grep -E "mt7927_init_dma|fw_sync|SLP_STS|phantom|FW ready|mcu-evt"
```

### 1.4 参考代码位置

| 参考源 | 路径 | 用途 |
|--------|------|------|
| 上游 mt7925 (Linux) | `/home/user/mt7927/mt76/mt7925/` | 工作代码参考（最重要） |
| 上游 DMA | `/home/user/mt7927/mt76/mt792x_dma.c` | DMA 初始化参考 |
| 上游 MCU | `/home/user/mt7927/mt76/mt7925/mcu.c` | MCU 命令格式 |
| Vendor 移动端 | `/home/user/mt7927/mt6639/` | 芯片特定寄存器 |
| Vendor SoC 初始化 | `/home/user/mt7927/mt6639/chips/soc3_0/soc3_0.c` | wf_pwr_on_consys_mcu() |
| Windows 逆向 | `/home/user/mt7927/WiFi_AMD-MediaTek_v5.7.0.5275/` | Ghidra 反编译 |
| Windows 逆向文档 | `/home/user/mt7927/docs/win_v5705275_*.md` | 已分析的函数 |

---

## 2. 当前进度总结

### 2.1 总体状态

```
[██████████████░░░░░░░░] ~65% 固件下载已完成

✅ PCIe 枚举和 BAR0 映射
✅ WFSYS reset + MCU ROM 启动
✅ HOST TX DMA (ring 15/16) 完全工作
✅ 固件下载（patch + RAM）完成
✅ RAM 固件启动成功 (fw_sync=0x3)
✅ Post-boot 基础设施（UNI_CMD 结构、NIC_CAP 查询框架）
⚠️ MCU → HOST 事件响应不工作（幻影 DMA 事件）
❌ Post-boot MCU 命令无响应
❌ ieee80211 注册
❌ 数据通路
❌ Station Mode
```

### 2.2 两阶段问题

**阶段 1 (FWDL 期间)**：MCU ROM 处理 HOST TX 命令并执行固件下载，但事件响应不写入 HOST RX 缓冲区。驱动通过 phantom DMA 事件的 ctrl 字段（DMA_DONE + len）推断成功，实际数据全是 0xDE 预填充。**固件下载依然成功**，因为 ROM 不需要 host 确认事件内容。

**阶段 2 (固件启动后)**：RAM 固件启动 (fw_sync=0x3)，但 MCU TX rings 全部 BASE=0x00000000，MCU 无法通过 DMA 向 HOST 发送任何数据。Post-boot 的 UNI_CMD 命令发出后无响应。

---

## 3. 已实现的功能

### 3.1 MCU 初始化序列 (`mt7927_mcu_init_mt6639()`, line 2628)

```
1. CONNINFRA wakeup (MT_WAKEPU_TOP=1, MT_WAKEPU_WF=1)
2. cbinfra PCIe remap (0x1f6554=0x74037001, 0x1f6558=0x70007000)
3. EMI sleep protection enable (0x18011100 BIT(1) via L1 remap)
4. AP2CONN sleep protection check (0xe0184 BIT(5)=0)
5. VDNR enable attempt (0xfE06C — 无效，返回 0x87654321)
6. WFSYS semaphore reset (0xf0018 BIT(0)=0)
7. WFSYS reset (0xf0140: clear BIT(0), wait 50ms, set BIT(0), poll BIT(4))
8. 睡眠保护 hammer 循环 (20000 iterations, 200ms)
9. CONN_INFRA 睡眠保护 disable (0xf1440, 0xf1620/0xf1624)
10. MCU ROM idle 等待 (poll ROMCODE_INDEX == 0x1D1E)
11. MCU ownership set (0x1f5034 BIT(0))
12. MCIF remap (0xd1034 = 0x18051803)
```

### 3.2 DMA 初始化 (`mt7927_dma_init()`, line 3541)

```
1. WFDMA logic reset (RST BIT(4)|BIT(5) pulse)
2. TX ring 15 (MCU WM, 256 desc) + TX ring 16 (FWDL, 128 desc)
3. RX ring 6 (MCU events, 128 desc, 2048B buffers, 0xDE prefill)
4. RX ring 0 (post-boot events, 128 desc)
5. Dummy RX rings 4,5,7 (prefetch chain 不阻塞)
6. Vendor prefetch EXT_CTRL (RX4-7, TX0-3, TX15-16)
7. GLO_CFG: MT76_SET | BIT(9) DMASHDL_BYPASS | BIT(20) LBK_RX_Q_SEL | BIT(26) ADDR_EXT
8. DMASHDL bypass (0xd6004 BIT(28))
9. Interrupt enable (HOST_INT_ENA, MCU2HOST_SW_INT_ENA=0xFFFF)
10. MCU DMA RX0/RX1 CIDX fix (set to CNT-1)
11. NEED_REINIT signal (0x02120 BIT(1))
```

### 3.3 固件下载 (`mt7927_mcu_fw_download()`, line 2487)

```
Patch: patch_sem_get → (per region: init_download → scatter chunks) → patch_finish → patch_sem_release
RAM:   (per region: init_download(+encrypt flags!) → scatter chunks) → FW_START_OVERRIDE
Boot:  poll CONN_ON_MISC bits[1:0]=3 (fw_sync=0x3 = FW N9 Ready)
```

**关键发现**: RAM region 的 `feature_set` 包含 `FW_FEATURE_SET_ENCRYPT` (BIT(0))。必须在 `init_download` 的 mode 中传递 `DL_MODE_ENCRYPT | DL_MODE_RESET_SEC_IV`。否则 MCU 会将加密数据直接写入内存而不解密，导致 ROMCODE=0xdead1234 崩溃。

### 3.4 Post-Boot 基础设施 (line 1576-1747)

```
- mt76_connac2_mcu_uni_txd 结构 (56 bytes: 32B TXD + 24B header)
- mt7927_mcu_send_uni_cmd(): UNI_CMD + TLV 格式
- mt7927_mcu_get_nic_capability(): CHIP_CONFIG (0x0e) tag=0x03
- mt7927_mcu_fw_log_2_host(): WSYS_CONFIG (0x0b) tag=0x00
- mt7927_mcu_set_eeprom(): EFUSE_CTRL (0x2d) tag=0x02
```

### 3.5 Post-Boot 恢复 (`mt7927_mcu_post_boot_init()`, line 1840)

```
1. Clear MCU_CMD and HOST_INT_STA
2. 恢复被固件覆写的 HOST RX ring 寄存器 (BASE/CNT/CIDX)
3. CONN_INFRA 睡眠保护 disable (correct reg 0xf1440 + old reg 0xf1620/1624)
4. GLO_CFG DMASHDL bypass 恢复
5. Interrupt enable 恢复
6. Wait WFSYS_INIT_DONE (MCU_CMD BIT(15))
7. CID probe: 发送 PATCH_SEM_CONTROL 测试事件通路
8. NIC capability query (UNI_CMD)
9. FW log enable (UNI_CMD)
10. EEPROM config (UNI_CMD)
```

---

## 4. 当前阻塞问题

### 4.1 核心问题：MCU → HOST DMA 通路不通

**现象**: 固件成功启动 (fw_sync=0x3)，但 MCU TX rings 全部 BASE=0x00000000。MCU 没有 DMA 路径向 HOST 发送数据。

**影响**: 所有 MCU 事件/响应不可接收。FWDL 阶段的"phantom events"（DMA_DONE=1 但数据=0xDE）和 post-boot UNI_CMD 无响应都是这个原因。

### 4.2 Phantom DMA 事件详解

```
# FWDL 阶段 RX6 desc[0] 在 MCU 处理完命令后：
ctrl  = 0xc02c0000  → DMA_DONE=1, len=44
buf0  = 0x01201000  → 被覆写为 MCU 侧地址（不是我们的 DMA 地址）
data  = de de de de de de de de ...  → 缓冲区从未被写入

# Post-boot 阶段 RX6/RX0 desc：
所有 DIDX=0  → WFDMA 从未向任何 HOST RX ring 写入
```

**分析**: WFDMA 内部标记了描述符完成（修改 ctrl 字段和 buf0），但实际数据从未通过 PCIe 写入 HOST 内存。buf0 被覆写为 MCU 侧 SRAM 地址 (0x0b027000, 0x5006x000) 表明 WFDMA 在尝试使用 MCU 的内存地址而非 HOST 的 DMA 地址。

### 4.3 SLP_STS=0x07770313 状态

这是 R2A AXI 桥的睡眠状态，**但已证明它不阻塞 DMA**：
- 所有 scatter + MCU 命令在此状态下正常流动
- HOST TX DIDX 正常推进，MIB 计数器确认
- 固件成功下载并启动

**结论**: SLP_STS 可能只是 MCU → HOST 方向空闲的反映（因为 MCU TX rings 未配置），而非阻塞原因。

### 4.4 CLR_OWN 不工作

上游 mt7925 在 DMA init + NEED_REINIT 后做 SET_OWN → CLR_OWN power cycle 来触发 MCU ROM 重新初始化 WFDMA（包括配置 MCU TX rings）。

**在 MT7927 上**: 写 BIT(1) 到 LPCTL (0xe0010) 后，BIT(2) OWN_SYNC 永远不清除。10 次重试全部失败。

---

## 5. 已排除的假设

### 按类别分组

#### DMA 配置类
| # | 假设 | 测试 | 结果 |
|---|------|------|------|
| 1 | Prefetch depth/base 错误 | 完全匹配 vendor 值 | ✗ |
| 2 | GLO_CFG 缺 BIT(20) LBK_RX_Q_SEL | 已添加 | ✗ |
| 3 | GLO_CFG vendor bits (BIT(9)/BIT(20)/BIT(26)) 导致问题 | clean_glo_cfg=1 测试 | ✗ 幻影事件不变 |
| 4 | DMA 使能时序错误 | 两阶段使能 | ✗ |
| 5 | RX pause threshold 缺失 | 已写入 0x00020002 | ✗ |
| 6 | DMASHDL 阻塞 | BIT(28) bypass ON | ✗ |
| 7 | WFDMA 逻辑残留 | 逻辑复位 toggle | ✗ |
| 8 | RX ring 编号 (0 vs 6) | evt_ring_qid=0/6 都试过 | ✗ |
| 9 | EXT0 寄存器值错 | 写入/跳过/清除 BIT(6) | ✗ |
| 10 | HOST_CONFIG PDMA_BAND BIT(0) | 只用于 multi-HIF | ✗ |
| 11 | MCU DMA RX0/RX1 CIDX=0 无空间 | 写 CIDX=CNT-1 | ✗ DIDX 仍=0 |
| 12 | TXD Q_IDX 路由到未配置的 MCU RX | 改 Q_IDX=2 路由到 RX2 | ✗ |

#### 地址/映射类
| 13 | MCIF remap 地址错 | 修正为 0xd1034=0x18051803 | ✗ |
| 14 | MCU ownership 未设 | 已写 0x1f5034 BIT(0) | ✗ |
| 15 | cbinfra remap 缺失 | 已配置 0x74037001 | ✗ |

#### 睡眠保护类
| 16 | CONN_INFRA WF 睡眠保护 (0x18001620) | clear BIT(0) | ✗ 已是 0 |
| 17 | CONN_INFRA WFDMA 睡眠保护 (0x18001624) | clear BIT(0) | ✗ 已是 0 |
| 18 | 正确寄存器 0xf1440 睡眠保护 | 20000 次 hammer | ✗ BIT(0) 从未置位 |
| 19 | WFDMA AXI_SLPPROT (0xd7050) | clear EN bits | ✗ 已是 0 |
| 20 | R2A CLKGATE_BYP/BUFRDY_BYP | 设置 BIT(12)+BIT(13) | ✗ SLP_STS 不变 |
| 21 | SLP_STS W1C 直接清除 | 写 1 到 SLP_STS | ✗ 只读 |

#### 初始化序列类
| 22 | 需要 WFSYS reset 而非 CB_INFRA_RGU | 两种都试过 | ✗ |
| 23 | 需要 SET_OWN power cycle | SET_OWN→CLR_OWN | ✗ CLR_OWN 失败 |
| 24 | VDNR enable (0xfE06C) | 返回 0x87654321 | ✗ 寄存器不存在 |
| 25 | EMI sleep protection 缺失 | L1 remap 设 BIT(1) | ✗ |
| 26 | HOST2MCU 软中断缺失 | 每次 kick 后写 BIT(0) | ✗ |
| 27 | WFDMA_DUMMY_CR NEED_REINIT 缺失 | 已设 BIT(1) | ✗ |

#### 电源/时序类
| 28 | 早期 DMA init 竞争 MCU ROM | DMA init 11ms vs ROM 40μs | ✗ |
| 29 | WFSYS power domain via L1 remap | PCIe 变体不适用 | ✗ |
| 30 | 固件加密标志缺失 | 已添加 DL_MODE_ENCRYPT | ✓ 这个确实解决了崩溃 |

---

## 6. 代码架构与关键函数

### 6.1 文件结构 (单文件 `mt7927_init_dma.c`, 4621 行)

```
Lines 1-460      : 宏定义、寄存器地址、常量
Lines 461-600    : 数据结构 (mt76_desc, mt76_connac2_mcu_txd/uni_txd, fw headers, rings)
Lines 601-750    : 模块参数 (~30 个可调参数)
Lines 750-920    : 辅助函数 (mt7927_rr/wr, wr_verify, dump_dma_state, dma_disable)
Lines 920-1000   : Ring 分配 (mt7927_ring_alloc, mt7927_rx_ring_alloc)
Lines 1010-1260  : MCU 事件等待 (mt7927_wait_mcu_event_on) + 超时诊断
Lines 1263-1476  : MCU 命令发送 (mt7927_kick_ring_buf, mt7927_mcu_send_cmd, send_scatter)
Lines 1476-1575  : 固件下载协议 (patch_sem_ctrl, init_download, start_patch, start_firmware)
Lines 1576-1747  : Post-boot UNI_CMD 接口 (send_uni_cmd, get_nic_capability, fw_log, eeprom)
Lines 1749-2313  : Post-boot 初始化 (post_boot_diag, post_boot_init)
Lines 2315-2507  : 固件加载 (load_patch, load_ram, fw_download)
Lines 2509-2610  : DMA path probe + cleanup + L1 remap helpers
Lines 2612-3105  : MCU 初始化 (mcu_init_mt6639) — 两条路径: WFSYS_SW_RST 和 CB_INFRA_RGU
Lines 3107-3407  : 睡眠保护 (disable_wfdma_slpprot, clear_r2a_bridge)
Lines 3409-3540  : drv_own, manual_prefetch, dma_reprogram_rings
Lines 3541-4135  : DMA 完整初始化 (dma_init) — 最长的函数
Lines 4137-4559  : probe/remove
Lines 4560-4622  : PCI ID 表, module_pci_driver
```

### 6.2 Probe 流程图

```
mt7927_probe()
  ├── pci_enable_device / pci_set_master / pci_iomap
  ├── SET_OWN → CLR_OWN (CLR_OWN 总是失败, LPCTL=0x4)
  ├── mt7927_mcu_init_mt6639()
  │     ├── CONNINFRA wakeup
  │     ├── cbinfra PCIe remap
  │     ├── EMI sleep protection
  │     ├── VDNR, WFSYS semaphore
  │     ├── WFSYS reset (0xf0140 toggle)
  │     ├── Sleep protection hammer (20000 iters)
  │     └── [if !use_wfsys_reset: vendor CB_INFRA_RGU flow]
  ├── mt7927_disable_wfdma_slpprot() (L1 remap + direct BAR0)
  ├── MCU ROM idle wait (ROMCODE=0x1D1E)
  ├── MCU ownership + MCIF remap
  ├── mt7927_drv_own() (CLR_OWN — 总是失败)
  ├── mt7927_clear_r2a_bridge() (SLPPROT_CTRL, R2A_CTRL0/CTRL2)
  ├── mt7927_dma_init()
  │     ├── Ring alloc (TX15, TX16, RX0, RX4-7)
  │     ├── Prefetch setup
  │     ├── GLO_CFG + interrupts
  │     ├── DMASHDL bypass
  │     ├── MCU DMA RX CIDX fix
  │     └── NEED_REINIT signal
  ├── Power cycle: SET_OWN → CLR_OWN (失败)
  ├── DMA reprogram + re-init
  ├── mt7927_mcu_fw_download()
  │     ├── mt7927_load_patch()
  │     │     ├── patch_sem_get
  │     │     ├── per-region: init_download + scatter chunks
  │     │     ├── patch_finish
  │     │     └── patch_sem_release
  │     └── mt7927_load_ram()
  │           ├── per-region: init_download(+encrypt!) + scatter chunks
  │           ├── FW_START_OVERRIDE
  │           └── poll fw_sync=0x3 ✅
  └── mt7927_mcu_post_boot_init()
        ├── RX ring register restoration
        ├── Sleep protection disable
        ├── DMASHDL/interrupt restore
        ├── Wait WFSYS_INIT_DONE
        ├── CID probe (test event path)
        ├── NIC capability query (UNI_CMD) → timeout
        ├── FW log enable → timeout
        └── EEPROM config → timeout
```

### 6.3 关键模块参数

| 参数 | 默认 | 说明 | 改过吗？ |
|------|------|------|---------|
| `skip_dma_probe` | true | 跳过 q16 DMA probe（避免 HIF_BUSY 死锁） | ✅ 必须 true |
| `use_wfsys_reset` | true | 用上游 WFSYS reset 替代 CB_INFRA_RGU | 两种都试过 |
| `force_wf_reset` | true | 即使 MCU 已 idle 也强制 reset | ✅ 必须 true |
| `evt_ring_qid` | 6 | MCU 事件 RX ring (CONNAC3X 用 6) | 0 和 6 都试过 |
| `clean_glo_cfg` | false | 去掉 vendor bits 用纯上游 GLO_CFG | 试过，无效 |
| `post_boot_qidx` | -1 | Post-boot TXD Q_IDX (-1=0x20, 17=vendor) | 试过 17 |
| `cid_probe_after_boot` | true | 启动后发 CID 格式命令测试事件通路 | 永远 timeout |

---

## 7. 硬件寄存器地图

### 7.1 Bus2Chip 映射表 (MT6639 PCIe)

```
Chip Address      BAR0 Offset    Size     用途
────────────────  ─────────────  ───────  ──────────────────────────────
0x54000000       0x02000        0x1000   MCU WPDMA0 (DUMMY_CR, DMA rings)
0x55000000       0x03000        0x1000   MCU WPDMA0 DMA1
0x56000000       0x05000        0x1000   MCU WFDMA WRAP
0x57000000       0x06000        0x1000   PCIe1 MCU DMA0
0x70000000       0x1e0000       0x9000   CONN_SEMAPHORE
0x70020000       0x1f0000       0x10000  CB_INFRA (RGU, MISC0, SLP_CTRL)
0x7c000000       0xf0000        0x10000  CONN_INFRA (WFSYS_RST, HW_VER)
0x7c020000       0xd0000        0x10000  WF_HIF (DMASHDL, CONN_BUS_CR_VON)
0x7c060000       0xe0000        0x10000  CONN_HOST_CSR_TOP (LPCTL, WAKEPU)
0x81020000       0xc0000        0x10000  WF_TOP_CFG_ON (ROMCODE_INDEX)
0xd4000+         0xd4000        -        HOST WFDMA0 (直接映射)
0xd5000+         0xd5000        -        HOST WFDMA1 (直接映射)
0xd7000+         0xd7000        -        WFDMA EXT CSR (R2A bridge)
```

### 7.2 关键寄存器速查

```
HOST WFDMA0:
  0xd4200  HOST_INT_STA          0xd4204  HOST_INT_ENA
  0xd4208  WPDMA_GLO_CFG         0xd41f0  MCU_CMD_REG
  0xd41f4  MCU2HOST_SW_INT_ENA   0xd42b0  GLO_CFG_EXT0

DMA Rings:
  TX: 0xd4300+qid*16 (BASE/CNT/CIDX/DIDX)
  RX: 0xd4500+qid*16 (BASE/CNT/CIDX/DIDX)

MCU DMA0 (BAR0 0x02000):
  0x02208  MCU_DMA0_GLO_CFG      0x02204  MCU_DMA0_INT_ENA
  TX: 0x02300+ring*16             RX: 0x02500+ring*16
  0x02120  WPDMA0_DUMMY_CR (BIT(1)=NEED_REINIT)

R2A Bridge (BAR0 0xd7000):
  0xd7500  R2A_CTRL_0            0xd7520  R2A_AXI_SLP_STS
  0xd752c  R2A_FSM_CMD_ST        0xd7530  R2A_FSM_DAT_ST
  0xd7050  AXI_SLPPROT_CTRL

CONN_INFRA:
  0xf0140  WFSYS_SW_RST (BIT(0)=RST_B, BIT(4)=INIT_DONE)
  0xf1440  WF_SLP_CTRL (BIT(0)=EN) — CORRECT for MT6639
  0xf1620  WF_SLP_CTRL_OLD — reads 0 on MT6639!
  0xe0010  LPCTL (BIT(0)=SET_OWN, BIT(1)=CLR_OWN, BIT(2)=OWN_SYNC)
  0xe01A0  WAKEPU_TOP            0xe01A4  WAKEPU_WF
  0xe00f0  CONN_ON_MISC (bits[1:0]=fw_sync)

L1 Remap:
  0x155024 HIF_REMAP_L1 (control)
  0x130000 HIF_REMAP_BASE_L1 (64K window)
```

---

## 8. 思考数据与分析过程

### 8.1 为什么固件下载能成功但事件返回不了

**HOST → MCU 路径** (工作):
```
HOST CPU → 写 TX desc → CIDX doorbell →
WFDMA 读 HOST TX desc → 从 HOST 内存读数据 →
WFDMA 内部路由 → 写入 MCU DMA RX ring → MCU 处理
```
这条路径工作因为 HOST TX ring 由 HOST 配置，MCU DMA RX ring 由 ROM bootloader 配置 (RX0 BASE=0x00000000 但 CNT=0x200, RX2 BASE=0x0226ca00)。

**MCU → HOST 路径** (不工作):
```
MCU 处理完毕 → MCU CPU 写 MCU TX desc →
MCU DMA TX ring 未配置 (BASE=0x00000000!) →
× 无法发送
```
MCU TX rings 从未被配置。ROM 和 RAM 固件都没有设置 MCU TX ring BASE 地址。

### 8.2 上游 mt7925 是怎么让 MCU TX rings 工作的

上游流程:
```
1. probe: DMA init → NEED_REINIT signal (DUMMY_CR BIT(1)=1)
2. init_work (deferred): SET_OWN → CLR_OWN
   ↳ CLR_OWN 触发 MCU ROM 从睡眠唤醒
   ↳ ROM 发现 NEED_REINIT=1
   ↳ ROM 重新扫描 HOST DMA ring 配置
   ↳ ROM 配置 MCU TX rings 匹配 HOST RX rings
   ↳ ROM 清除 NEED_REINIT
3. 此后 MCU TX rings 有正确的 BASE 地址，可以 DMA 到 HOST
```

**我们的问题**: Step 2 的 CLR_OWN 在 MT7927 上不工作（BIT(2) OWN_SYNC 永远不清除），所以 MCU ROM 从不处理 NEED_REINIT，MCU TX rings 永远是 BASE=0。

### 8.3 睡眠保护的完整调查结论

经过对三层睡眠保护的完整调查:

1. **CONN_INFRA 层 (0x18001620/0xf1620)** — MT6639 上读为 0，不是正确的寄存器
2. **CONN_INFRA 层 (0xf1440)** — 正确寄存器但 BIT(0) 从未置位 (0 clears in 20000 iters)
3. **WFDMA 层 (0xd7050 AXI_SLPPROT_CTRL)** — EN bits 已是 0

**结论**: 所有软件可控的睡眠保护都已禁用。SLP_STS=0x07770313 是硬件级状态，反映 R2A 桥的 AXI 通道空闲/睡眠。它**不阻塞 HOST→MCU DMA**（已证明），但可能反映 **MCU→HOST 方向因 MCU TX rings 未配置而空闲**。

### 8.4 Phantom 事件的机制推测

WFDMA 在 MCU 处理完命令后，在 HOST RX ring 描述符上标记 DMA_DONE，但这可能是 WFDMA 的内部簿记行为而非真正的数据传输。描述符的 buf0 被覆写为 MCU 侧地址（而非 HOST DMA 地址），表明 WFDMA 误用了 MCU 的内部地址。

### 8.5 为什么 VDNR 和 CPU_SW_RST 在 PCIe 上不可用

0x7c000000 固定映射区域 (64K) 在不同芯片变体上映射到不同物理寄存器:
- 0x7c000140 (WFSYS_SW_RST): ✓ 所有变体通用
- 0x7c000010 (CPU_SW_RST): 返回 0x1d2 — PCIe 上是版本/ID 寄存器
- 0x7c001000 (CONN_HW_VER): 返回 0x80000000 — MT6639 PCIe 版本 ID 不同于 SoC3_0 的 0x20010000
- 0x7c00E06C (VDNR): 返回 0x87654321 — 死区，寄存器不存在

上游 mt7925 只使用 0x7c000140 (WFSYS_SW_RST)，不触碰其他 CONN_INFRA 寄存器。

---

## 9. 下一步方向

### 9.1 方向 A: 解决 CLR_OWN（最关键）

CLR_OWN 是 MCU TX ring 配置的唯一已知触发方式。可能的子方向:

**A1: 研究上游 mt7925 在 CLR_OWN 前做了什么特殊配置**
```bash
# 关键文件
Read /home/user/mt7927/mt76/mt792x_core.c  # mt792x_pm_power_save_work
Read /home/user/mt7927/mt76/mt7925/pci.c    # mt7925e_mcu_init
```
上游在 `mt792x_pm_power_save_work()` 中做 SET_OWN 前可能有特定的 WF wakeup 或 LPCTL 预处理。

**A2: PCIe 配置空间对 CLR_OWN 的影响**
CLR_OWN 可能需要特定的 PCIe 电源状态 (D0) 或 ASPM 配置。检查:
```bash
sudo lspci -vvv -s 09:00.0  # 查看 power state 和 ASPM
```

**A3: 检查 LPCTL 寄存器地址是否正确**
0xe0010 来自 mt7925 (chip 0x7c060010)。MT6639 可能在不同地址。搜索 Windows 逆向找 LPCTL 写入。

### 9.2 方向 B: 直接从 HOST 配置 MCU TX rings

如果 CLR_OWN 无法修复，尝试绕过:
```c
// MCU DMA0 TX0 在 BAR0 0x02300
// 设置 BASE = 某个 MCU SRAM 地址（如 0x0b027000）
// 或者指向我们分配的 DMA coherent buffer
iowrite32(dma_addr, dev->bar0 + 0x02300);  // TX0 BASE
iowrite32(128, dev->bar0 + 0x02304);       // TX0 CNT
iowrite32(0, dev->bar0 + 0x02308);         // TX0 CIDX
```
**风险**: 不知道 MCU TX ring BASE 应该指向什么内存。ROM/firmware 可能期望特定的 MCU SRAM 区域。

### 9.3 方向 C: 研究 Windows 驱动的 CLR_OWN / 初始化流程

```bash
# 已有的 Windows 逆向文档
ls /home/user/mt7927/docs/win_v5705275_*.md
```
搜索 Windows 驱动中 LPCTL 相关操作、以及 MCU TX ring 配置时序。

### 9.4 方向 D: 尝试发送第二次 NEED_REINIT

```
1. DMA init → NEED_REINIT
2. WFSYS reset (不清除 HOST DMA config)
3. ROM 启动 → 读到 NEED_REINIT=1
4. ROM 配置 MCU TX rings
```
问题: WFSYS reset 可能清除 HOST DMA 配置。需要测试。

### 9.5 方向 E: 检查 MCU DMA INT_ENA

```
MCU_DMA0 INT_ENA = 0x00000000 (全禁用)
```
MCU DMA 中断全部禁用。也许需要使能后 MCU CPU 才会触发 DMA 传输。

### 9.6 优先级建议

1. **方向 A1** (研究上游 CLR_OWN 上下文) — 最可能的正确路径
2. **方向 C** (Windows 逆向) — 确认性的补充
3. **方向 B** (直接配置 MCU TX rings) — 风险较高但快速验证
4. **方向 E** (MCU DMA INT_ENA) — 简单，值得快速测试
5. **方向 D** (第二次 NEED_REINIT) — 可能不工作但快速测试

---

## 10. 参考代码指南

### 10.1 上游 mt7925 关键函数

```
mt7925/pci.c:mt7925e_probe()       — 完整 probe 流程
mt7925/pci.c:mt7925e_mcu_init()    — MCU 初始化（deferred work）
mt792x_dma.c:mt792x_dma_enable()   — DMA 使能 + NEED_REINIT
mt792x_dma.c:mt792x_wfsys_reset()  — WFSYS reset
mt792x_core.c:mt792x_pm_power_save_work() — SET_OWN
mt792x_core.c:mt792x_connac_pm_wake()     — CLR_OWN
mt7925/mcu.c:mt7925_mcu_fw_pmctrl()       — fw_pmctrl (SET_OWN)
mt7925/mcu.c:mt7925_mcu_drv_pmctrl()      — drv_pmctrl (CLR_OWN)
```

### 10.2 Vendor mt6639 关键函数

```
chips/soc3_0/soc3_0.c:wf_pwr_on_consys_mcu() — 完整 WFSYS 上电序列（18步）
chips/mt6639/mt6639.c:mt6639_mcu_init()       — MCU 初始化 + MCIF remap
chips/mt6639/mt6639.c:mt6639WfdmaManualPrefetch() — prefetch 设置
chips/common/cmm_asic_connac3x.c              — CONNAC3X DMA 通用配置
```

### 10.3 Windows 逆向关键文档

```
docs/win_v5705275_fw_flow.md          — 固件下载完整流程
docs/win_v5705275_core_funcs.md       — 核心函数列表
docs/win_v5705275_dma_lowlevel.md     — DMA 底层操作
docs/win_v5705275_mcu_send_core.md    — MCU 命令发送核心
```

---

## 11. 操作手册

### 11.1 常用命令

```bash
# 完整构建+测试循环
echo 123456 | sudo -S rmmod mt7927_init_dma 2>/dev/null; \
make tests && \
echo 123456 | sudo -S insmod tests/04_risky_ops/mt7927_init_dma.ko && \
sleep 3 && \
echo 123456 | sudo -S dmesg | tail -200

# 带参数加载
echo 123456 | sudo -S insmod tests/04_risky_ops/mt7927_init_dma.ko \
    use_wfsys_reset=0 clean_glo_cfg=1

# 查看当前参数
cat /sys/module/mt7927_init_dma/parameters/skip_dma_probe

# 过滤关键日志
echo 123456 | sudo -S dmesg | grep -E "mt7927_init_dma" | \
    grep -E "FW ready|fw_sync|SLP_STS|MCU_TX|phantom|timeout|ROMCODE|LPCTL|CLR_OWN"

# 查看 PCIe 设备状态
sudo lspci -vvv -s 09:00.0 | head -30

# 手动 PCIe reset (危险! FLR 会让设备进入 D3cold 不恢复!)
# echo 123456 | sudo -S bash -c 'echo 1 > /sys/bus/pci/devices/0000:09:00.0/reset'
# ⚠️ 不要执行! 见致命陷阱 #1
```

### 11.2 dmesg 关键行解读

```
fw_sync=0x00000003          → ✅ 固件启动成功
ROMCODE=0x00001d1e          → ✅ MCU ROM idle
ROMCODE=0xdead1234          → ❌ MCU crash (加密标志错误)
MCU_CMD=0x00008000          → ✅ WFSYS_INIT_DONE
SLP_STS=0x07770313          → ⚠️ AXI 桥空闲（不一定是问题）
SLP_STS=0x00000000          → ✅ AXI 桥活跃
LPCTL=0x00000004            → ❌ CLR_OWN 失败 (OWN_SYNC 仍为 1)
LPCTL=0x00000000            → ✅ CLR_OWN 成功
MCU_TX0: BASE=0x00000000    → ❌ MCU TX ring 未配置（核心问题）
MCU_TX0: BASE=0x0XXXXXXX    → ✅ MCU TX ring 已配置
HIF_BUSY=0x80000002         → ⚠️ txfifo1 有数据卡住
evt-data: de de de de       → ❌ phantom event (数据未写入)
```

---

## 12. 致命陷阱清单

### ☠️ 陷阱 #1: PCIe FLR 致命

**`pcie_flr()` / `pci_reset_function()` 会将 MT7927 置入 D3cold，设备永远无法恢复。**

不要使用:
```c
pci_reset_function(pdev);   // 死锁: probe 持有 device mutex
pcie_flr(pdev);             // 设备进入 D3cold 不恢复
```
也不要:
```bash
echo 1 > /sys/bus/pci/devices/0000:09:00.0/reset  # 同上
```

### ☠️ 陷阱 #2: `pci_reset_function()` 在 probe 中死锁

probe 持有 device mutex，`pci_reset_function()` 也要获取同一个 mutex → 自死锁，需要硬重启。

### ☠️ 陷阱 #3: q16 DMA probe kick 导致 HIF_BUSY 死锁

`skip_dma_probe=1` 必须为 true。不要在 DMA init 后立即 kick q16 进行探测，这会导致 HIF_BUSY 锁定，后续所有 DMA 操作失败。

### ☠️ 陷阱 #4: 缺少加密标志导致 MCU 崩溃

RAM firmware region 的 `feature_set` 包含 `FW_FEATURE_SET_ENCRYPT` (BIT(0))。如果 `init_download` 的 mode 参数不包含 `DL_MODE_ENCRYPT | DL_MODE_RESET_SEC_IV`，MCU 会将加密数据直接写入内存不解密 → ROMCODE=0xdead1234。

### ⚠️ 陷阱 #5: CLR_OWN 永远不工作

写 BIT(1) 到 LPCTL (0xe0010) 后 BIT(2) OWN_SYNC 不清除。这不是 bug，可能是 MT7927 PCIe 变体的行为差异。上游 mt7925 使用相同的 LPCTL 地址但在不同硬件上。

### ⚠️ 陷阱 #6: VDNR/CPU_SW_RST 寄存器在 PCIe 上不存在

- 0xfE06C (VDNR) → 返回 0x87654321 (死区)
- 0xf0010 (CPU_SW_RST) → 返回 0x1d2 (不是 reset 控制器)
- 这些寄存器是 SoC 变体专用，PCIe 变体没有

### ⚠️ 陷阱 #7: 0xf1620/0xf1624 是错误的睡眠保护寄存器

这些是 mt7915 时代的寄存器，在 MT6639 上读为 0x00000000。正确的寄存器是 0xf1440/0xf1444，但在 MT7927 上 BIT(0) 也从未被硬件置位。

### ⚠️ 陷阱 #8: dmesg 溢出

per-chunk scatter dump 会在固件下载时生成大量日志。已通过 `if (ring->qid != 16)` 抑制 q16 的 per-kick dump。如果添加新的日志，注意不要在热路径中输出。

---

## 附录 A: 模块参数完整表

| 参数 | 类型 | 默认 | 说明 |
|------|------|------|------|
| fw_ram | charp | "mediatek/WIFI_RAM_CODE_MT6639_2_1.bin" | RAM 固件路径 |
| fw_patch | charp | "mediatek/WIFI_MT6639_PATCH_MCU_2_1_hdr.bin" | Patch 固件路径 |
| enable_predl_regs | bool | false | Windows 风格的 pre-download 寄存器序列 |
| wm_ring_qid | int | 15 | MCU WM TX ring (15 或 17) |
| wait_mcu_event | bool | true | 每条 MCU 命令后等待 RX 事件 |
| scatter_via_wm | bool | false | 通过 WM ring 发送 scatter (Windows 风格) |
| strict_dma_probe | bool | false | DMA probe 失败时中止 probe |
| tx_kick_use_didx | bool | false | 用 DIDX doorbell 替代 CIDX |
| minimal_dma_cfg | bool | false | 最小 DMA 配置 (调试) |
| use_mt6639_init | bool | true | MT6639 MCU 初始化序列 |
| use_mt6639_patch_addr | bool | true | 使用 MT6639 patch 地址 0x900000 |
| force_wf_reset | bool | true | 强制 WF reset 即使 MCU 已 idle |
| no_long_format | bool | false | TXD DW1 不设 LONG_FORMAT |
| evt_ring_qid | int | 6 | RX 事件 ring (0=connac2, 6=connac3) |
| skip_ext0 | bool | true | 跳过 GLO_CFG_EXT0 写入 |
| skip_logic_rst | bool | false | 跳过 WFDMA logic reset |
| use_wfsys_reset | bool | true | 用上游 WFSYS reset (0xf0140) |
| r2a_clkgate_byp | bool | false | R2A 时钟门控旁路 |
| use_emi_slpprot | bool | true | EMI sleep protection |
| mcu_rx_qidx | int | 0 | CONNAC3 TXD Q_IDX |
| fix_mcu_rx_cidx | bool | true | 修正 MCU DMA RX CIDX |
| clean_glo_cfg | bool | false | 纯上游 GLO_CFG (无 vendor bits) |
| use_upstream_txd | bool | true | 上游 TXD 格式 |
| upstream_prefetch | bool | false | 上游 prefetch (RX0-3) |
| disable_ext0_dmashdl | bool | true | 清除 EXT0 DMASHDL |
| skip_dma_probe | bool | true | 跳过 DMA path probe |
| skip_reinit | bool | true | 跳过 post-boot WFDMA reinit |
| post_boot_qidx | int | -1 | Post-boot TXD Q_IDX |
| wait_wfsys_init | bool | true | 等待 WFSYS_INIT_DONE |
| cid_probe_after_boot | bool | true | 启动后 CID 格式事件通路测试 |
| mcif_remap_reg | uint | 0xd1034 | MCIF remap 寄存器 BAR0 偏移 |
| mcif_remap_val | uint | 0x18051803 | MCIF remap 值 |

## 附录 B: 最后一次成功运行的 dmesg 关键行

```
# 固件下载成功
FW ready: fw_sync=0x00000003 after 0ms
MCU_CMD=0x00008000 (WFSYS_INIT_DONE)
ROMCODE_INDEX=0xdead1234 (正常——RAM firmware 覆写了 ROM 的 idle 标记)

# MCU TX rings 未配置（核心问题）
MCU_DMA0 TX0: BASE=0x00000000 CNT=0x00000000 CIDX=0x00000000 DIDX=0x00000000
MCU_DMA0 TX1: BASE=0x00000000 CNT=0x00000000 CIDX=0x00000000 DIDX=0x00000000
MCU_DMA0 TX2: BASE=0x00000000 CNT=0x00000000 CIDX=0x00000000 DIDX=0x00000000
MCU_DMA0 TX3: BASE=0x00000000 CNT=0x00000000 CIDX=0x00000000 DIDX=0x00000000

# 幻影事件
mcu-evt: q6 idx=0 ctrl=0xc02c0000 len=44 buf0=0x01201000 dma=0x4fdec000
evt-data: de de de de de de de de de de de de de de de de

# 睡眠保护（不是阻塞因素）
slpprot-hammer: 20000 iters, 0 clears, 4 zeros, 89741 us total
SLP_STS=0x07770313 (从未改变)
```

## 附录 C: TODO 路线图 (来自 docs/mt7927_TODO.md)

全部阻塞在 MCU→HOST 事件通路修复:

- **P0 T1**: UNI_CMD 发送函数 (框架已实现，需要事件响应)
- **P0 T2**: NIC Capability 查询 (代码已写，timeout)
- **P0 T3**: EEPROM/eFuse 配置
- **P0 T4**: 固件日志启用
- **P1 T5**: MAC 寄存器初始化
- **P1 T6**: ASPM L0s 禁用
- **P2 T7**: ieee80211_register_hw
- **P3 T8-T10**: IRQ 处理 + 数据 TX/RX
- **P4 T11-T12**: 扫描 + 认证/关联
- **P5 T13-T14**: 电源管理 + 杂项
