# MT7927 Driver Development - Complete Handoff Document
# Date: 2026-02-15 (Session 3)

---

## Table of Contents
1. [Project Overview](#1-project-overview)
2. [Quick Start for New Session](#2-quick-start)
3. [Architecture & Hardware](#3-architecture)
4. [What Works](#4-what-works)
5. [Current Blocker: R2A FSM State Change](#5-current-blocker)
6. [Complete Evidence: PRE vs POST Boot Register Comparison](#6-evidence)
7. [All Failed Approaches (DO NOT RETRY)](#7-failed-approaches)
8. [Key Discoveries This Session](#8-discoveries)
9. [Upstream mt7925 Analysis](#9-upstream)
10. [Next Steps & Recommended Investigation](#10-next-steps)
11. [Reference Codebases](#11-references)
12. [Hardware Safety Notes](#12-safety)
13. [File Layout & Build System](#13-file-layout)

---

## 1. Project Overview {#1-project-overview}

### What
A **Linux WiFi driver for MediaTek MT7927** (PCI ID: 14c3:6639, internal name MT6639/CONNAC3X).
This is a combo WiFi 7 + Bluetooth PCIe card found on recent AMD motherboards (e.g., ASUS ROG STRIX X870-I).
**No upstream Linux support exists** for the WiFi interface of this chip.

### Why
The chip only works on Windows. Bluetooth works on Linux via USB (community patches exist).
WiFi uses a completely separate PCIe/WFDMA interface and requires a new driver from scratch.

### Approach
Single-file experimental kernel module (`tests/04_risky_ops/mt7927_init_dma.c`, ~10500 lines)
that performs bare-metal register-level initialization:
- PCIe BAR0 mapping
- WFDMA DMA ring allocation (HOST side TX/RX rings)
- Power management (SET_OWN/CLR_OWN) for ROM firmware handshake
- WFSYS reset + full WFDMA configuration
- Firmware download (ROM patch + 6 RAM regions)
- Post-boot MCU command interface

### Current Milestone
**Establish bidirectional MCU command communication** with running firmware.
- HOST → MCU (command path): DMA completes but data vanishes after FW boot
- MCU → HOST (event path): untestable until commands work

### What's NOT done yet
- mac80211/cfg80211 registration
- Wireless scanning/association
- Data path (802.11 frames)
- Power management
- Rate control
- Any actual WiFi functionality

---

## 2. Quick Start for New Session {#2-quick-start}

### First Commands
```bash
# Read this file and memory
cat docs/HANDOFF_2026-02-15_v2.md
cat ~/.claude/projects/-home-user-mt7927/memory/MEMORY.md

# Build
cd /home/user/mt7927 && make tests

# Load driver (mode 11 = current standard mode)
sudo rmmod mt7927_init_dma 2>/dev/null
sudo insmod tests/04_risky_ops/mt7927_init_dma.ko reinit_mode=11 skip_dma_probe=1

# Check output
dmesg | tail -300

# Filtered key events
dmesg | grep -E "mt7927|mode11|Phase|CLR_OWN|MCU_TX|fw_sync|FWDL|timeout|result|FSM|R2A"
```

**sudo password**: `123456`

### Key Files to Read (Priority Order)
1. **This file** — current status, findings, next steps
2. **Memory** — `~/.claude/projects/-home-user-mt7927/memory/MEMORY.md`
3. **Driver source** — `tests/04_risky_ops/mt7927_init_dma.c`
4. **Investigation plan** — `docs/investigation_mcu_tx_rings.md`

### Module Parameters (Most Important)
```
reinit_mode=11      # Standard mode: SET_OWN→CLR_OWN + FWDL + post-boot test
skip_dma_probe=1    # MUST set: skip q16 DMA probe that causes HIF_BUSY deadlock
use_upstream_txd=1  # (default) Use upstream mt76 TXD format (Q_IDX=0x20)
post_boot_qidx=-1   # (default) -1 = use same Q_IDX as FWDL (0x20)
skip_reinit=1       # (default) Skip WFDMA reinit after FW boot (upstream pattern)
```

---

## 3. Architecture & Hardware {#3-architecture}

### PCIe Device
```
PCI: 14c3:6639 (MediaTek MT6639 / MT7927)
BDF: 0000:09:00.0
BAR0: 0xf2000000 (2MB) — main register space
BAR2: 0xf2200000 (32KB) — secondary
```

### WFDMA DMA Ring Layout

**HOST side (BAR0 offsets)**:
```
TX rings:  0xd4300 + qid*0x10  (BASE/CNT/CIDX/DIDX)
RX rings:  0xd4500 + qid*0x10
TX EXT:    0xd4600 + qid*4     (prefetch config)
RX EXT:    0xd4680 + qid*4
GLO_CFG:   0xd4208
INT_ENA:   0xd4204
INT_STA:   0xd4200
```

**MCU DMA0 (BAR0 offsets, MCU-internal)**:
```
MCU TX:    0x02300 + idx*0x10  (MCU→HOST, BASE always 0x00000000 — NORMAL)
MCU RX:    0x02500 + idx*0x10  (HOST→MCU, RX2/RX3 configured by ROM)
MCU TX EXT: 0x02600 + idx*4
MCU RX EXT: 0x02680 + idx*4
GLO_CFG:   0x02208
INT_ENA:   0x02204
```

### Ring Assignments
| Ring | Purpose | Status |
|------|---------|--------|
| HOST TX15 | MCU WM commands (init_download, fw_start, UNI_CMD) | Working during FWDL, broken post-boot |
| HOST TX16 | FWDL scatter data (raw firmware chunks) | Working |
| HOST RX0 | MCU events (post-boot) | Allocated, DIDX never advances |
| HOST RX6 | MCU events (FWDL stage) | Working during FWDL, DIDX=12 after boot |
| MCU_RX0 | HOST→MCU post-boot commands | BASE=0x00000000 (not configured) |
| MCU_RX1 | HOST→MCU | BASE=0x00000000 |
| MCU_RX2 | HOST→MCU FWDL commands | BASE=0x0226ca00 (ROM configured, SRAM) |
| MCU_RX3 | HOST→MCU FWDL data | BASE=0x0226cc80 (ROM configured, SRAM) |
| MCU_TX0-3 | MCU→HOST events | BASE=0x00000000 (NORMAL — see discovery #1) |

### Command Flow
```
HOST→MCU (FWDL, WORKING):
  1. Build TXD with Q_IDX=0x20 in TX15 descriptor
  2. Write CIDX+1 to TX15 CIDX register → kicks WFDMA
  3. WFDMA DMAs data, R2A bridge routes to MCU via Q_IDX
  4. MCU_RX2 DIDX advances → MCU reads command
  5. MCU sends response → appears on HOST RX6

HOST→MCU (Post-boot, BROKEN):
  1. Same TXD, same Q_IDX=0x20, same TX15 ring
  2. Write CIDX+1 → WFDMA DMAs data (CIDX=DIDX advances)
  3. R2A bridge FSM is in different state → data VANISHES
  4. MCU_RX0-3 DIDX unchanged → MCU never sees command
  5. Timeout after 2000ms → -110 (ETIMEDOUT)
```

### R2A Bridge (Register-to-AXI)
The R2A bridge is the internal WFDMA component that routes data between HOST
PCIe DMA and MCU DMA. It has an FSM (finite state machine) that changes state
when firmware boots. This FSM change is THE root cause of the failure.

```
R2A registers (BAR0 offsets):
  CTRL0: 0xd7508 (read-only, same in all states: 0xffff0c08)
  CTRL1: 0xd750c (read-only, same in all states: 0x1ffe7ff8)
  CTRL2: 0xd7510 (read-only, same in all states: 0x86ffff1f)
  FSM_CMD: 0xd752c (read-only, changes with FW boot)
  FSM_DAT: 0xd7530 (read-only, changes with FW boot)
  SLP_STS: 0xd7534 (always 0x07770313, does NOT block DMA)
```

---

## 4. What Works {#4-what-works}

### SET_OWN → CLR_OWN Power Cycle
- Must SET_OWN (BIT(0)→LPCTL 0xe0010) first, wait OWN_SYNC=1
- Then CLR_OWN (BIT(1)→LPCTL), wait OWN_SYNC=0 (~10ms)
- ROM processes NEED_REINIT: resets HOST rings, configures MCU_RX2/RX3
- Our `mt7927_dma_reprogram_rings()` restores HOST rings after wipe

### Firmware Download (Complete End-to-End)
```
Sequence:
  1. patch_sem_get
  2. init_download (patch address)
  3. scatter × N (ROM patch data via TX16)
  4. patch_finish
  5. patch_sem_release
  6. For each of 6 RAM regions:
     a. init_download (addr, len, DL_MODE_ENCRYPT|DL_MODE_RESET_SEC_IV)
     b. scatter × N (firmware data via TX16, max_len=4096)
  7. FW_START_OVERRIDE (option=1)
  8. Poll fw_sync=0x3 (CONN_ON_MISC 0xe00f0 bits[1:0])
```
fw_sync=0x3 achieved immediately after FW_START ACK.

### HOST DMA Ring Allocation & Configuration
- 2 TX rings (q15=WM, q16=FWDL), 8 RX rings (q0-q7)
- Prefetch config (EXT_CTRL), GLO_CFG, DMASHDL bypass, interrupt enables
- All verified working during FWDL phase

---

## 5. Current Blocker: R2A FSM State Change {#5-current-blocker}

### The Problem in One Sentence
After firmware boots, the WFDMA's internal R2A bridge changes state, causing
HOST TX15 data (MCU commands) to vanish instead of reaching MCU_RX rings.

### Detailed Symptom
```
Before FW_START:
  - TX15 CID=0x01 Q_IDX=0x20 → CIDX/DIDX advance → response on RX6 ✓
  - R2A FSM_CMD = 0x03030101 (WORKING)

After FW boot (fw_sync=0x3):
  - TX15 UNI_CMD Q_IDX=0x20 → CIDX/DIDX advance → NO response anywhere ✗
  - R2A FSM_CMD = 0x01010202 (BROKEN)
  - MCU_RX0-3 DIDX all unchanged (data never arrives at MCU)
  - No events on any HOST RX ring (RX0-7 DIDX all unchanged)
```

### What This Means
1. The HOST DMA engine successfully transfers the descriptor+data (CIDX=DIDX)
2. The WFDMA prefetch engine reads the descriptor
3. The R2A bridge is supposed to forward the data to the MCU
4. In the new FSM state (0x01010202), the bridge silently drops the data
5. The MCU never sees the command → no response → timeout

### R2A FSM State Table (Consistent Across ALL Modes)
| State | FSM_CMD | FSM_DAT | Working? |
|-------|---------|---------|----------|
| Pre-FW_START (ROM active) | 0x03030101 | 0x00000303 | YES |
| Post-FW_BOOT (RAM FW active) | 0x01010202 | 0x00000101 | NO |
| After LOGIC_RST (mode 22) | 0x01010303 | 0x00000101 | NO |

### Why This Is Hard
- FSM registers are **READ-ONLY** from HOST
- Firmware boot changes them internally
- ALL other HOST-visible registers are IDENTICAL pre/post boot
- No known HOST-side register controls the FSM routing
- Upstream mt7925 presumably doesn't have this issue (different chip)

---

## 6. Complete Evidence: PRE vs POST Boot Register Comparison {#6-evidence}

Fresh data from mode 11 run (2026-02-15):

### Registers That DO NOT Change
```
HOST GLO_CFG      (0xd4208)  = 0x5410ba75  (identical)
HOST GLO_EXT0     (0xd42b0)  = 0x28c004df  (identical)
HOST GLO_EXT1     (0xd42b4)  = 0x9c800404  (identical)
HOST_CFG          (0xd7030)  = 0x00007d00  (identical)
HOST RST          (0xd420c)  = 0x00000030  (identical)
DMASHDL SW        (hif)      = 0x10000000  (identical)
SLP_PROT          (0xf1440)  = 0x00000004  (identical)
R2A_STS           (0xd7514)  = 0x00000000  (identical)
R2A CTRL0         (0xd7508)  = 0xffff0c08  (identical)
R2A CTRL1         (0xd750c)  = 0x1ffe7ff8  (identical)
R2A CTRL2         (0xd7510)  = 0x86ffff1f  (identical)
MCU_DMA0 GLO      (0x02208)  = 0x10703875  (identical)
MCU_DMA0 EXT0     (0x022b0)  = 0x28c0049f  (identical)
MCU_DMA0 INT_ENA  (0x02204)  = 0x00000000  (identical)
MCU_DMA0 RST      (0x0220c)  = 0x00000000  (identical)
MCU_DMA1 GLO      (0x03208)  = 0x00000000  (identical, disabled)
MCU_RX0 BASE      (0x02500)  = 0x00000000  (identical, not configured)
MCU_RX1 BASE      (0x02510)  = 0x00000000  (identical, not configured)
MCU_RX2 BASE      (0x02520)  = 0x0226ca00  (identical, ROM configured)
MCU_RX3 BASE      (0x02530)  = 0x0226cc80  (identical, ROM configured)
MCU_TX0-3 BASE    (0x023x0)  = 0x00000000  (identical, NORMAL)
TX15 EXT_CTRL     (0xd463c)  = 0x05800004  (identical, NOT reset by FW boot)
TX16 EXT_CTRL     (0xd4640)  = 0x02c00004  (identical)
All RX EXT_CTRL   (0xd4680+) = (identical)
WFDMA1 GLO        (0xd5208)  = 0x00000000  (identical, disabled)
DISP_CTRL         (0xd70A0)  = 0x00000000  (identical)
HIF_MISC          (0xd7044)  = 0x001c2000  (identical)
R2A WR0/WR1/RD0/RD1         = (identical)
MSI_INT_CFG0-3               = (identical)
HOST RX ring BASEs           = (identical, our DMA addresses preserved)
HOST TX ring BASEs           = (identical)
```

### Registers That DO Change
```
R2A FSM_CMD  (0xd752c) = 0x03030101 → 0x01010202  ← THE CHANGE
R2A FSM_DAT  (0xd7530) = 0x00000303 → 0x00000101  ← THE CHANGE
R2A SLP_STS  (0xd7534) = 0x07770313 → 0x07770313  (same, listed for completeness)
DUMMY_CR     (0x02120) = 0xffff0002 → 0xffff0003   (BIT(0) set by FW = fw_ready)
MCU_CMD      (0xd41f0) = 0x00000000 → 0x00008000   (BIT(15) = WFSYS_INIT_DONE)
CONN_MISC    (0xe00f0) = 0x00000001 → 0x00000003   (fw_sync = 0x3)
ROMCODE      (0xc1604) = 0xdead1234 → 0xdead1234   (same)
HOST_INT_STA (0xd4200) = varies                      (interrupt status)
```

---

## 7. All Failed Approaches (DO NOT RETRY) {#7-failed-approaches}

### Mode 11: Standard (SET_OWN→CLR_OWN + FWDL + post-boot)
- Result: NIC_CAPABILITY timeout -110
- FSM changes to 0x01010202 after FW boot

### Mode 12: Skip SET_OWN→CLR_OWN
- Result: FWDL works! But post-boot NIC_CAPABILITY timeout -110
- Same FSM transition, proves it's caused by FW boot, not our init

### Mode 15: Full WFDMA config re-enable after FW boot
- Result: -110

### Mode 16: Post-boot SET_OWN→CLR_OWN + UNI command
- Result: Running FW handles CLR_OWN differently from ROM.
  No WFDMA reset, no MCU TX ring config. -110

### Mode 20: Clear NEED_REINIT before FWDL + L0S_DIS
- Result: FWDL works, DUMMY_CR=0xffff0001 (NEED_REINIT cleared).
  MCU_TX still BASE=0, NIC_CAPABILITY -110

### Mode 22: Full DMA reset (LOGIC_RST) after FW boot
- Result: LOGIC_RST changes FSM to 0x01010303 (yet another broken state).
  DMASHDL bypass cleared, TX DIDX stuck at 0 (stale descriptor mismatch). -110

### HOST2MCU_SW_INT_SET Signals
- PDMA0_STOP_DONE (BIT(0)) → no effect
- PDMA0_INIT_DONE (BIT(1)) → no effect
- PDMA0_RECOVERY_DONE (BIT(3)) → no effect
- All combined → no effect
- Both MCU-side (0x02108) and HOST-side (0xd4108) → no effect
- With and without MCU_DMA0_INT_ENA=0xFF → no effect

### Different Q_IDX Values
- Q_IDX=0x20 (MT_TX_MCU_PORT_RX_Q0) → works pre-boot, fails post-boot
- Q_IDX=0x3e (MT_TX_MCU_PORT_RX_FWDL) → fails post-boot
- Q_IDX=17 (vendor hint) → fails post-boot

### Mode 23: Minimal post-boot (ZERO register writes)
- Result: -110. Even with zero register writes between fw_sync=0x3 and
  NIC_CAPABILITY, command fails. Confirms FW boot itself is the cause.
- BUT: Revealed that R2A FSM_CMD RECOVERS to 0x03030101 after ~2s (see Discovery 6)

### Mode 25: Wait for R2A FSM recovery (10s poll)
- Result: -110. FSM_CMD stayed 0x01010202 for full 10s of passive polling.
  Only recovered ~2s AFTER a DMA command was sent (at 12s post-boot).
- Suggests DMA activity may trigger FSM transition (see Discovery 7)

### Various Register Manipulations
- Writing MCU_DMA0_INT_ENA=0xFF: writable, readback confirmed, no effect
- Clearing/setting NEED_REINIT in DUMMY_CR: no effect on MCU TX rings
- W1C MCU_CMD WFSYS_INIT_DONE: MCU_CMD keeps reasserting 0x8000
- Sleep protection disable (SLP_CTRL/SLP_STATUS): no effect
- PCIe FLR: FATAL, device enters D3cold, never recovers. DO NOT USE.
- pci_reset_function(): deadlocks (probe holds device mutex)

---

## 8. Key Discoveries This Session {#8-discoveries}

### Discovery 1: MCU_TX BASE=0 is NORMAL (Not the Blocker)
**Previous assumption**: MCU_TX rings with BASE=0 meant MCU couldn't send events.
**Truth**: MCU events are delivered via HOST RX rings (RX0 for post-boot, RX6 for
FWDL). The MCU DMA-writes responses directly to HOST physical memory using the
HOST RX ring descriptor addresses. MCU_TX rings serve a different purpose.
MCU_TX BASE=0 is observed even BEFORE FWDL (when everything works).

### Discovery 2: ALL Host-Visible Registers Identical Pre/Post Boot
Exhaustive comparison of 50+ register groups shows the ONLY difference is the
R2A FSM state (0x03030101→0x01010202). The firmware changes something internal
to the WFDMA that's invisible from the HOST register space.

### Discovery 3: EXT_CTRL NOT Reset by FW Boot (Correcting Earlier Claim)
Earlier code comments claimed "Firmware boot resets ALL EXT_CTRL to 0x00000004".
This is WRONG. Fresh test shows TX15_EXT=0x05800004 identical pre and post boot.
All EXT_CTRL values are preserved.

### Discovery 4: Upstream mt7925 Sends Commands Immediately After fw_sync
The upstream mt7925 driver's post-boot sequence is:
```
mt7925e_mcu_init():
  1. SET_OWN (fw_pmctrl)
  2. CLR_OWN (drv_pmctrl)
  3. L0S_DIS (MT_PCIE_MAC_PM at 0x10194)
  4. mt7925_run_firmware():
     a. load_patch + load_ram + FW_START
     b. Poll fw_sync=0x3
     c. IMMEDIATELY send NIC_CAPABILITY ← first MCU command
     d. load_clc, set MCU_RUNNING
  5. Cleanup FWDL queue
```
NO register writes between fw_sync=0x3 and NIC_CAPABILITY.
NO WFSYS_INIT_DONE wait, NO interrupt acknowledge, NO event draining.
Our mode 11 does ~400ms of register manipulation between fw_sync and command.

### Discovery 5: R2A FSM State Byte Encoding Hypothesis
```
FSM_CMD = [byte3][byte2][byte1][byte0]
Working:  0x03  0x03  0x01  0x01
Broken:   0x01  0x01  0x02  0x02
```
Hypothesis: byte values may encode routing destinations:
- 0x01 = idle/passthrough
- 0x02 = routed to WFDMA1 (disabled!)
- 0x03 = routed to MCU_DMA0

If FW boot switches routing to WFDMA1 (completely disabled, GLO=0x00000000),
data would be silently dropped. This is UNVERIFIED but fits all observations.

### Discovery 6: R2A FSM State Change Is TRANSIENT (Session 4)
**The R2A FSM_CMD returns to 0x03030101 (working) after FW completes
internal initialization.** This was discovered in mode 23:
```
Time 0.0s (fw_sync=0x3): FSM_CMD=0x01010202  (broken)
Time 2.0s (after timeout): FSM_CMD=0x03030101  (working!)
```
The FSM change is NOT permanent. It represents a transient FW init window.
Commands sent during this window are lost because the R2A bridge can't
route them properly yet.

### Discovery 7: FSM Recovery May Be DMA-Triggered (Session 4)
Mode 25 polled FSM_CMD for 10 seconds with no DMA activity — FSM stayed
0x01010202 the entire time. Only after a DMA command was sent (CIDX kick)
did the FSM recover (~2s after the kick).

Contrast with mode 23 where a command was sent immediately: FSM recovered
within 2 seconds. This suggests:
- **Passive waiting does NOT trigger FSM recovery**
- **DMA activity (CIDX kick → WFDMA prefetch → R2A transfer attempt) may
  be required to trigger the FSM state transition**
- The first command's data is sacrificed (lost during broken FSM), but
  subsequent commands should work after FSM recovers

**Implication**: A "dummy command" pattern could work:
1. Send throwaway command → triggers FSM transition, data lost
2. Wait for FSM_CMD == 0x03030101 (~1-2s)
3. Send real command → should succeed

This is the most promising lead and should be tested next.

---

## 9. Upstream mt7925 Analysis {#9-upstream}

### Probe Sequence (mt7925/pci.c)
```
mt7925_pci_probe():
  1. PCIe enable + config
  2. fw_pmctrl (SET_OWN) → drv_pmctrl (CLR_OWN)  [first power cycle]
  3. mt792x_wfsys_reset()                          [WFSYS reset]
  4. mt7925_dma_init():
     - dma_disable(force=true)
     - Allocate TX queues (0-3, 15=WM, 16=FWDL)
     - Allocate RX queues (0=MCU, 2=data)
     - dma_enable() → sets NEED_REINIT, prefetch, interrupts
  5. mt7925_register_device() → async init_work
```

### Async Init (mt7925/init.c → pci_mcu.c)
```
mt7925_init_work():
  └→ mt7925_init_hardware():
     └→ mt792x_mcu_init():
        └→ mt7925e_mcu_init():
           1. fw_pmctrl (SET_OWN)
           2. drv_pmctrl (CLR_OWN)   [second power cycle, NEED_REINIT=1]
           3. L0S_DIS
           4. mt7925_run_firmware():
              a. FWDL → FW_START → fw_sync=0x3
              b. NIC_CAPABILITY (first MCU command, WORKS on mt7925)
              c. load_clc, set MCU_RUNNING
           5. Cleanup FWDL queue
```

### Key Difference from Our Driver
Upstream does a **second SET_OWN→CLR_OWN with NEED_REINIT=1** right before FWDL.
It does NOT reprogram HOST rings after this (unlike our driver which always reprograms).
This suggests either:
- MT7925 ROM doesn't wipe HOST rings during NEED_REINIT (different from MT7927)
- OR: The NEED_REINIT processing on MT7925 properly configures internal WFDMA routing
  in a way that PERSISTS through firmware boot

### Ring Assignments (mt7925)
- TX15 = MT7925_TXQ_MCU_WM (MCU commands)
- TX16 = MT7925_TXQ_FWDL (firmware data)
- RX0 = MT7925_RXQ_MCU_WM (MCU events, 512 descriptors)
- RX2 = MT7925_RXQ_BAND0 (802.11 data)
- All MCU commands use Q_IDX=0x20 (MT_TX_MCU_PORT_RX_Q0)

---

## 10. Session 4 New Experiments & Results (2026-02-15 continued)

### Mode 23: Minimal Post-Boot Test — TESTED, FAILED
**Rationale**: Upstream mt7925 sends NIC_CAPABILITY immediately after fw_sync=0x3
with ZERO register writes. Our mode 11 does ~400ms of manipulation. Mode 23
tests whether our register writes cause the breakage.

**Implementation** (code added to driver):
```
After fw_sync=0x3:
  1. Sync TX15 CIDX = DIDX (avoid stale descriptors)
  2. Reset mcu_seq = 0
  3. Send NIC_CAPABILITY IMMEDIATELY (no other register writes)
  4. Dump full diagnostic regardless of result
```

**Result**: **-110 (timeout)**. Even with ZERO register writes, the command fails.
This CONFIRMS firmware boot itself causes the routing breakage — not our init code.

**Key data from mode 23 run**:
```
POST-BOOT snapshot: FSM_CMD=0x01010202  (broken, right after fw_sync=0x3)
AFTER-CMD snapshot: FSM_CMD=0x03030101  (working, ~2s later!)
```
DMA completes (CIDX=0x0d, DIDX=0x0d), MCU_RX0-3 DIDX unchanged, no events
on any HOST RX ring.

### CRITICAL Discovery: R2A FSM State Is TRANSIENT

Mode 23 revealed that the R2A FSM state change is **not permanent**:
```
Time 0.0s (right after fw_sync=0x3): FSM_CMD=0x01010202  (broken)
Time 2.0s (after command timeout):   FSM_CMD=0x03030101  (working!)
```
The FSM returns to the working state after the firmware finishes its
internal initialization. But our command was already sent and lost.

### Mode 25: Wait For R2A FSM Recovery — TESTED, CONTRADICTORY

Mode 25 polls FSM_CMD every 10ms for up to 10 seconds, waiting for it to
return to 0x03030101 before sending NIC_CAPABILITY.

**Result**: FSM_CMD stayed at `0x01010202` for the ENTIRE 10 seconds!
```
[mode25] 0ms:    FSM_CMD=0x01010202  (broken)
[mode25] 1000ms: FSM_CMD=0x01010202
[mode25] 2000ms: FSM_CMD=0x01010202
...
[mode25] 9000ms: FSM_CMD=0x01010202  (still broken after 10s!)
```
The FSM never recovered during passive polling. NIC_CAPABILITY sent anyway → -110.

But the AFTER-CMD snapshot (taken ~2s after the command was sent) shows:
```
FSM_CMD=0x03030101  (working again, ~12s after boot)
```

**Contradiction Analysis**:
- Mode 23: FSM recovered to 0x03030101 within ~2s of boot
- Mode 25: FSM stayed 0x01010202 for 10s, only recovered ~12s after boot

**Possible explanations**:
1. The DMA activity from sending a command (CIDX kick) triggers the FSM
   transition. In mode 23, the command was sent at 0s, FSM recovered by 2s.
   In mode 25, no DMA activity for 10s, FSM stuck; command at 10s, recovered
   by 12s. This suggests the R2A bridge needs a DMA transaction to complete
   its state machine transition.
2. The FSM recovery timing is non-deterministic and varies between boots.
3. Something about the polling itself (reading FSM registers 1000 times)
   affects the FSM behavior.

### Mode 24: WFDMA1 Experiment — NOT YET TESTED

**Implementation** (code added to driver):
```
After FW boot:
  1. Dump WFDMA1 + MCU_DMA1 detailed ring state
  2. Enable WFDMA1 GLO_CFG at 0xd5208 (TX_DMA_EN + RX_DMA_EN)
  3. Enable MCU_DMA1 GLO_CFG at 0x03208
  4. Sync TX15 CIDX, reset mcu_seq
  5. Send NIC_CAPABILITY
  6. Check WFDMA1 RX rings + all HOST RX rings for response
```

**Status**: Code written but not tested. Lower priority now given FSM
transience discovery.

---

## 10a. Updated Next Steps & Recommended Investigation

### Priority 1: [HIGH] Dummy Command to Trigger FSM Recovery
**Rationale**: Mode 23 showed FSM recovers ~2s after a DMA kick. Mode 25 showed
it does NOT recover with passive polling alone. This strongly suggests the
R2A bridge needs a DMA transaction to trigger its state machine transition.

**Proposed mode 26 approach**:
```
After fw_sync=0x3:
  1. Sync TX15 CIDX = DIDX
  2. Send a "throwaway" command (any simple CID-based or UNI command)
     - Don't wait for response (it will be lost)
     - This just triggers the R2A DMA → FSM transition
  3. Wait for FSM_CMD to become 0x03030101 (poll, expected ~1-2s)
  4. Sync TX15 CIDX = DIDX again (clean up after throwaway)
  5. Reset mcu_seq
  6. Send real NIC_CAPABILITY
```

**Why this might work**: The throwaway command's DMA kick causes R2A to
transition. After transition completes, the bridge routes normally. The
real command then reaches MCU.

**Alternative**: Instead of a full command, just write a dummy descriptor
and kick CIDX to generate DMA activity without consuming a real MCU command.

### Priority 2: [HIGH] Verify FSM Recovery Causality
**Rationale**: Need to confirm that DMA activity causes FSM recovery.

**Test**: After fw_sync=0x3, just kick CIDX+1 (with a dummy/empty descriptor)
and poll FSM_CMD. If FSM recovers quickly → DMA-triggered. If not → coincidence.

### Priority 3: [HIGH] Read HOST RX6 Events Content
**Rationale**: RX6 DIDX=12 after FWDL. These events may contain handshake
info the driver must process. Perhaps processing them triggers FW to enter
normal command mode.

**Implementation**: After FWDL, read RX6 descriptors 0..11, parse as MCU
events, log in detail. The `mt7927_drain_rx_events()` function exists and
can do this (mode 11 already calls it but its results weren't analyzed).

### Priority 4: [MEDIUM] WFDMA1 Experiment (mode 24)
**Rationale**: If FSM byte 0x02 means "route to WFDMA1", data might be
going there. Code written, just run `reinit_mode=24`.

### Priority 5: [MEDIUM] WFDMA Dispatch Control Register (0xd70A0)
**Rationale**: Reads 0x00000000. Controls WFDMA internal routing.

### Priority 6: [LOW] Windows Driver Trace Comparison
**Rationale**: Windows driver works. Ghidra trace of post-FW_START code
would reveal what it does differently.

### Priority 7: [LOW] Compare R2A FSM With Known-Good mt7925
**Rationale**: Check if mt7925 also sees FSM change after FW boot.

---

## 11. Reference Codebases {#11-references}

| Directory | Description | Key Files |
|-----------|-------------|-----------|
| `mt76/mt7925/` | Upstream Linux mt7925 (closest relative) | `pci.c`, `pci_mcu.c`, `mcu.c`, `mt7925.h` |
| `mt76/mt792x_dma.c` | Shared DMA code for mt792x family | `dma_enable()`, `dma_disable()`, `wpdma_reset()` |
| `mt76/mt76_connac3_mac.h` | CONNAC3 TXD/Q_IDX definitions | `tx_mcu_port_q_idx` enum |
| `mt76/mt76_connac_mcu.c` | Shared MCU command code | `init_download()`, `start_firmware()` |
| `mt6639/` | Vendor mobile driver (Android, same chip) | `cmm_asic_connac3x.c`, `hal_pdma.c`, `fw_dl.c` |
| `WiFi_AMD-MediaTek_v5.7.0.5275/` | Windows driver + Ghidra RE | Binary + decompiled functions |
| `docs/win_v5705275_*.md` | Windows RE analysis notes | Register maps, function traces |
| `docs/mt76_vs_windows_mt7927.md` | Linux vs Windows register comparison | |

### Key Upstream Files for Post-Boot Sequence
```
mt76/mt7925/pci_mcu.c:27-53     — mt7925e_mcu_init() (THE init function)
mt76/mt7925/mcu.c:1045-1063     — mt7925_run_firmware() (FWDL + first MCU cmd)
mt76/mt7925/mcu.c:3470-3540     — mt7925_mcu_fill_message() (TXD construction)
mt76/mt792x_core.c:854-876      — __mt792xe_mcu_drv_pmctrl() (CLR_OWN)
mt76/mt792x_core.c:899-924      — mt792xe_mcu_fw_pmctrl() (SET_OWN)
mt76/mt792x_dma.c:126-170       — mt792x_dma_enable() (DMA + NEED_REINIT)
mt76/mt792x_dma.c:253-300       — mt792x_dma_disable() (DMA off + LOGIC_RST)
```

---

## 12. Hardware Safety Notes {#12-safety}

### FATAL Operations (NEVER DO)
- **`pcie_flr()`**: Puts device into D3cold, never recovers. Requires cold reboot.
- **`pci_reset_function()`**: Deadlocks in probe context (device mutex self-lock).
  Requires hard reboot.

### Safe Operations
- All WFDMA register writes (0xd4xxx range)
- All MCU_DMA register writes (0x02xxx, 0x03xxx)
- SRAM reads/writes via BAR0
- SET_OWN / CLR_OWN power cycles (recoverable)
- WFSYS reset (0xf0140)
- LOGIC_RST pulse (0xd420c)
- Module unload: `sudo rmmod mt7927_init_dma` (always works)

### Recovery
- If chip hangs: `sudo rmmod mt7927_init_dma` usually recovers
- Worst case: warm reboot
- No permanent damage risk: we never write eFuse/OTP

---

## 13. File Layout & Build System {#13-file-layout}

```
/home/user/mt7927/
├── tests/04_risky_ops/
│   ├── mt7927_init_dma.c         # THE driver (~10500 lines)
│   └── Makefile                  # test module build
├── Makefile                      # top-level: `make tests` builds driver
├── mt76/                         # upstream reference (READ-ONLY)
│   ├── mt7925/                   # closest relative driver
│   ├── mt792x_dma.c             # shared DMA code
│   ├── mt792x_core.c            # power management
│   ├── mt76_connac3_mac.h       # CONNAC3 definitions
│   └── mt76_connac_mcu.c        # shared MCU command code
├── mt6639/                       # vendor mobile driver (READ-ONLY)
│   ├── chips/common/            # CONNAC3X common code
│   ├── chips/mt6639/            # chip-specific
│   └── os/linux/hif/common/     # HAL DMA code
├── WiFi_AMD-MediaTek_v5.7.0.5275/  # Windows driver + Ghidra
├── docs/                         # analysis docs & handoffs
│   ├── HANDOFF_2026-02-15_v2.md # THIS FILE
│   ├── investigation_mcu_tx_rings.md
│   ├── win_v5705275_*.md        # Windows RE analysis
│   └── mt76_vs_windows_mt7927.md
├── linux-driver-mediatek-mt7927-bluetooth-main/  # BT (USB, not for WiFi)
└── linux-mediatek-mt6639-bluetooth-kernel-module-main/  # BT patches
```

### Build Commands
```bash
# Build driver module
make tests

# Load driver
sudo rmmod mt7927_init_dma 2>/dev/null
sudo insmod tests/04_risky_ops/mt7927_init_dma.ko reinit_mode=11 skip_dma_probe=1

# Check output
dmesg | tail -300

# Quick re-test cycle
make tests && sudo rmmod mt7927_init_dma 2>/dev/null && \
  sudo insmod tests/04_risky_ops/mt7927_init_dma.ko reinit_mode=11 skip_dma_probe=1 && \
  sleep 8 && dmesg | tail -300
```

---

## Appendix: TXD Format Reference

### FWDL Command TXD (CID-based, 64 bytes header)
```
DW0: FIELD_PREP(MT_TXD0_TX_BYTES, len) |
     FIELD_PREP(MT_TXD0_PKT_FMT, MT_TX_TYPE_CMD=1) |
     FIELD_PREP(MT_TXD0_Q_IDX, 0x20)
DW1: FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_CMD=1)
     (NO LONG_FORMAT bit)

struct mt76_connac2_mcu_txd:
  .txd[0..7]  = 32 bytes (8 x u32)
  .len        = payload length (excluding txd[0..7])
  .pq_id      = MCU_PQ_ID(MT_TX_PORT_IDX_MCU, 0x20)
  .cid        = command ID (0x01=init_dl, 0x02=fw_start, etc.)
  .pkt_type   = MCU_PKT_ID (0xa0)
  .seq        = sequence number (1-15, auto-increment)
  .s2d_index  = 0 (MCU_S2D_H2N)
```

### Post-Boot UNI Command TXD (56 bytes header)
```
Same DW0/DW1 format as above.

struct mt76_connac2_mcu_uni_txd:
  .txd[0..7]  = 32 bytes
  .len        = payload length
  .cid        = UNI command ID (0x0e=CHIP_CONFIG, etc.)
  .pkt_type   = MCU_PKT_ID (0xa0)
  .seq        = sequence number
  .option     = 0x03 (UNI_CMD_OPT_BIT_0_ACK | UNI_CMD_OPT_BIT_1_UNI_CMD)
  Payload: 4-byte reserved + TLV (tag u16 + len u16 + data)
```

---

*End of handoff document. Good luck.*
