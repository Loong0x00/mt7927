# MT7927 Driver Development Status - 2026-02-15

## Project Overview

We are writing a **Linux WiFi driver for MediaTek MT7927** (hardware ID: MT6639/CONNAC3X,
PCI 14c3:6639) from scratch. There is no upstream Linux support for this chip yet.
The chip is found on recent AMD motherboards (ASUS ROG STRIX X870 etc.) as a combo
WiFi 7 + Bluetooth PCIe card.

### Goal
Get WiFi working on Linux. Current milestone: establish bidirectional MCU command
communication with running firmware (HOST↔MCU DMA).

### Approach
Single-file experimental driver (`tests/04_risky_ops/mt7927_init_dma.c`, 8022 lines)
that performs bare-metal register-level initialization: PCIe setup, WFDMA DMA ring
allocation, firmware download, and MCU command interface. No mac80211/cfg80211 yet.

---

## Quick Start for New Session

### First Commands
```bash
# Read this file and memory for context
cat docs/HANDOFF_2026-02-15.md
cat ~/.claude/projects/-home-user-mt7927/memory/MEMORY.md

# Build
cd /home/user/mt7927 && make tests

# Load driver (reinit_mode=11 is the current working mode)
sudo rmmod mt7927_init_dma 2>/dev/null
sudo insmod tests/04_risky_ops/mt7927_init_dma.ko reinit_mode=11 skip_dma_probe=1

# Check output
dmesg | tail -200
```
**sudo password**: `123456`

### Key Files to Read
1. **Driver source**: `tests/04_risky_ops/mt7927_init_dma.c` - the single driver file
2. **Memory**: `~/.claude/projects/-home-user-mt7927/memory/MEMORY.md` - persistent facts
3. **This file**: current status, completed/failed work, next steps

### Reference Codebases (in project root)
| Directory | Description |
|-----------|-------------|
| `mt76/mt7925/` | Upstream Linux mt7925 driver (closest relative, our primary reference) |
| `mt6639/` | Vendor mobile driver for MT6639 (same chip, Android/SoC variant) |
| `WiFi_AMD-MediaTek_v5.7.0.5275/` | Windows driver binaries + Ghidra RE output |
| `docs/win_v5705275_*.md` | Ghidra reverse engineering notes for Windows driver |
| `linux-driver-mediatek-mt7927-bluetooth-main/` | Community BT driver (USB, not useful for WiFi) |
| `linux-mediatek-mt6639-bluetooth-kernel-module-main/` | BT kernel patches (USB, not useful for WiFi) |

### Module Parameters
- `reinit_mode=11` - current working mode (SET_OWN→CLR_OWN + DMA reprogram + FWDL)
- `skip_dma_probe=1` - skip q16 DMA probe that causes HIF_BUSY deadlock
- Other modes (0-10) are older experiments, mostly obsolete

---

## Executive Summary

Firmware download and boot works end-to-end. HOST→MCU DMA path is functional.
**Blocker**: MCU→HOST DMA response path is broken because MCU TX rings (BASE=0x00000000)
are never configured by firmware, preventing any post-boot MCU command responses.

---

## Completed Tasks

### 1. SET_OWN → CLR_OWN Power Cycle (WORKING)
- **Discovery**: CLR_OWN alone never works. Must do SET_OWN first (BIT(0) to LPCTL),
  wait for OWN_SYNC=1, then CLR_OWN (BIT(1)). Clears in ~10ms.
- **Effect**: ROM processes NEED_REINIT flag, configures internal WFDMA routing.
- **Side effect**: ROM does FULL WFDMA reset - zeroes all HOST ring BASEs, disables
  GLO_CFG TX/RX DMA, clears INT_ENA and SW_INT_ENA.
- **Location**: `mt7927_mode11_pre_fwdl()` in mt7927_init_dma.c

### 2. HOST DMA Full Restore After CLR_OWN (WORKING)
- `mt7927_dma_reprogram_rings()` re-writes all HOST ring BASE/CNT/CIDX/DIDX from
  saved `dev->ring_*` structures.
- Restores GLO_CFG, GLO_CFG_EXT1, INT_ENA, MCU2HOST_SW_INT_ENA, DMASHDL bypass.
- Enables TX/RX DMA, sets WAKE_RX_PCIE.
- **Key insight**: Must reprogram AFTER every CLR_OWN cycle since ROM wipes everything.

### 3. Firmware Download (WORKING)
- Full FWDL sequence: patch_sem_get → init_download → scatter × N → patch_finish →
  patch_sem_release → (per RAM region: init_download → scatter × N) →
  FW_START_OVERRIDE(option=1) → poll fw_sync=0x3
- **Encryption flags critical**: DL_MODE_ENCRYPT | DL_MODE_RESET_SEC_IV required.
- **max_len=4096** for PCIe (not 2048).
- **skip_dma_probe=1** to avoid HIF_BUSY deadlock from q16 probe kick.
- fw_sync=0x3 achieved immediately after FW_START ACK.

### 4. MCU DMA0 INT_ENA Enable (VERIFIED WRITABLE)
- MCU_DMA0_INT_ENA (BAR0 0x02204) is writable from host.
- Write 0xFF enables host2mcu_sw_int_ena bits[7:0].
- Readback confirmed: 0x000000FF.
- However, enabling this alone does NOT cause MCU to configure TX rings.

### 5. WFSYS Reset + DMA Init (WORKING)
- WFSYS reset via 0xf0140 BIT(0) clear/set, poll INIT_DONE BIT(4)
- Full HOST WFDMA ring allocation (TX15/16 for commands, RX0-7 for events/data)
- EXT_CTRL dispatch config, prefetch config, DMA enable sequence

---

## Failed Approaches (Important: Do NOT Retry)

### Post-boot CLR_OWN Cycle
- Running firmware handles CLR_OWN differently from ROM.
- NEED_REINIT stays set (not processed), GLO_CFG not reset, HOST rings not wiped.
- MCU TX rings remain BASE=0x00000000. Completely ineffective.

### HOST2MCU_SW_INT_SET Signaling
Tried all combinations, none configured MCU TX rings:
- `MCU_INT_PDMA0_STOP_DONE` (BIT(0)) to 0x02108 - no effect
- `MCU_INT_PDMA0_INIT_DONE` (BIT(1)) to 0x02108 - no effect
- `MCU_INT_PDMA0_RECOVERY_DONE` (BIT(3)) to 0x02108 - no effect
- All bits combined to 0x02108 - no effect
- All bits to HOST-side 0xd4108 - no effect
- With and without MCU_DMA0_INT_ENA=0xFF enabled first

### CLR_OWN Without Prior SET_OWN
- Writing BIT(1) to LPCTL alone: OWN_SYNC (BIT(2)) never clears. Confirmed dead.

---

## Current Blocker: MCU TX Rings BASE=0x00000000

### Symptom
```
MCU_TX0: BASE=0x00000000 CNT=512 CIDX=0 DIDX=0
MCU_TX1: BASE=0x00000000 CNT=512 CIDX=0 DIDX=0
MCU_TX2: BASE=0x00000000 CNT=512 CIDX=0 DIDX=0
MCU_TX3: BASE=0x00000000 CNT=512 CIDX=0 DIDX=0
```

### Impact
- HOST→MCU works: commands consumed (q15 CIDX=DIDX after kick)
- MCU→HOST broken: no DMA path for event responses
- All post-boot MCU commands timeout (-110)

### What We Know
- MCU TX ring BASEs should point to MCU-internal SRAM (like MCU_RX2=0x0226ca00)
- MCU firmware allocates and configures these internally
- ROM never configures them (even during NEED_REINIT processing)
- Running firmware doesn't configure them on CLR_OWN wake
- HOST2MCU software interrupts don't trigger configuration
- MCU_DMA0 GLO=0x10703875 (TX_DMA_EN=1, RX_DMA_EN=1) - DMA engine is on
- MCU_RX2/RX3 are configured by ROM (SRAM addresses), MCU_RX0/RX1 are not

### Clue: HOST RX6 DIDX=12
After post-boot test, HOST RX6 shows DIDX=12 while CIDX=11. This means MCU
wrote 12 events to HOST RX6 at some point (likely during FWDL). The driver
didn't consume them during polling. This proves MCU CAN write to HOST RX
rings for FWDL-stage events, but post-boot events aren't flowing.

---

## Key Register State After FW Boot

```
HOST_GLO_CFG     (0xd4208) = 0x5410ba75  (TX/RX DMA enabled, working)
HOST_INT_ENA     (0xd4204) = 0x2e004007
HOST_INT_STA     (0xd4200) = check for pending interrupts
MCU_CMD          (0xd41f0) = 0x00008000  (WFSYS_INIT_DONE = BIT(15))
MCU2HOST_SW_INT  (0xd41f0) = MCU→HOST software interrupt status
CONN_ON_MISC     (0xe00f0) = fw_sync bits[1:0] = 3 (FW N9 ready)
LPCTL            (0xe0010) = 0x00000000 (driver owns device)
DUMMY_CR         (0x02120) = 0xffff0003  (NEED_REINIT=BIT(1), FW flags in upper 16)
MCU_DMA0_GLO     (0x02208) = 0x10703875  (TX/RX enabled)
MCU_DMA0_INT_ENA (0x02204) = 0x000000ff  (after our write; was 0x00000000)
MCU_DMA0_INT_STA (0x02200) = 0x00000000
MCU_DMA1_GLO     (0x03208) = 0x00000000  (completely disabled)
ROMCODE          (0xc1604) = valid (not 0xdead1234)
```

---

## Unexplored Directions (Recommended Priority Order)

### 1. [HIGH] Read HOST RX6 Events
RX6 DIDX=12 suggests FW wrote events during FWDL. These may contain initialization
info (TX resource allocation, NIC capability, etc.) that must be processed before
FW configures MCU TX rings for post-boot communication. **Read and dump the actual
DMA descriptor + payload content** of these 12 events.

### 2. [HIGH] Study Upstream mt7925 Post-Boot Sequence
The upstream mt7925 driver must have a working post-boot flow. Study exactly what
happens between `mt7925_run_firmware()` completing and first MCU command. Look at:
- `mt7925e_mcu_init()` in `mt76/mt7925/pci_mcu.c`
- `mt7925_mcu_init()` in `mt76/mt7925/mcu.c`
- How/when MCU TX rings get configured in upstream
- What drv_pmctrl / fw_pmctrl sequences happen

### 3. [MEDIUM] FWDL-Stage vs Post-Boot Response Ring
Vendor driver switches `rx_event_port` after FW_START:
- Before FW_START: events on RX_RING_EVT_IDX_0 (ring 0 or ring 6)
- After FW_START: events on WFDMA1_RX_RING_IDX_1
- Our driver may be polling wrong ring, or MCU_DMA1 (disabled) may be needed
- Consider enabling MCU_DMA1 GLO (0x03208)

### 4. [MEDIUM] MCU_RX0/RX1 Configuration
MCU_RX0 and MCU_RX1 have BASE=0x00000000 (unlike MCU_RX2/RX3 which ROM configured).
These might be the HOST→MCU command rings for post-boot (vs MCU_RX2/RX3 for FWDL).
Firmware may need MCU_RX0/RX1 configured before it sets up MCU_TX0/TX1.

### 5. [MEDIUM] Windows WFDMA Reconfig After FW Boot
Windows driver writes MSI_INT_CFG0-3 registers and other WFDMA config after fw_sync=0x3.
These may control MCU→HOST response routing. Not yet implemented.
See `docs/win_v5705275_dma_lowlevel.md` for details.

### 6. [LOW] Direct SRAM Write of MCU TX Ring BASEs
MCU TX rings point to MCU SRAM. We could try writing known SRAM addresses directly
to MCU_TX0 BASE (e.g., similar to MCU_RX2=0x0226ca00). Risky but testable.

---

## Hardware & Safety Notes

- **PCIe FLR is FATAL**: `pcie_flr()` puts device into D3cold, never recovers. DO NOT USE.
- **`pci_reset_function()` deadlocks**: probe holds device mutex, reset tries to acquire → hard reboot needed.
- **Chip survives most register writes**: WFDMA registers, MCU_DMA registers, SRAM etc. are safe to poke.
- **If chip hangs**: `sudo rmmod mt7927_init_dma` usually recovers. Worst case: reboot.
- **No permanent damage risk**: we never write to eFuse or OTP regions.

---

## Build & Test Commands

```bash
# Build
cd /home/user/mt7927 && make tests

# Load (current working mode)
sudo rmmod mt7927_init_dma 2>/dev/null
sudo insmod tests/04_risky_ops/mt7927_init_dma.ko reinit_mode=11 skip_dma_probe=1

# Check output
dmesg | tail -200

# Filtered output for key events
dmesg | grep -E "mt7927|mode11|Phase|CLR_OWN|MCU_TX|fw_sync|FWDL|timeout|result"

# Quick register probe (compile and run)
gcc -o /tmp/probe /tmp/probe_mcu_dma0.c && sudo /tmp/probe
```

## File Layout
```
/home/user/mt7927/
├── tests/04_risky_ops/mt7927_init_dma.c  # THE driver (8022 lines)
├── Makefile                               # top-level, `make tests` builds driver
├── mt76/mt7925/                           # upstream reference (READ-ONLY reference)
├── mt6639/                                # vendor mobile reference (READ-ONLY reference)
├── WiFi_AMD-MediaTek_v5.7.0.5275/         # Windows driver + Ghidra project
├── docs/                                  # analysis docs, handoffs, RE notes
│   ├── HANDOFF_2026-02-15.md              # THIS FILE
│   ├── win_v5705275_*.md                  # Windows driver reverse engineering
│   └── mt7927_dma_fw_status_*.md          # earlier status snapshots
├── linux-driver-mediatek-mt7927-bluetooth-main/   # community BT driver (USB, not for WiFi)
├── linux-mediatek-mt6639-bluetooth-kernel-module-main/  # BT patches (USB, not for WiFi)
├── scripts/                               # helper scripts
└── tmp/                                   # temp probe tools (probe_mcu_dma0.c etc.)
```

## Community BT Driver Status
- MT7927 Bluetooth works on Linux via USB interface (separate from PCIe WiFi)
- Patches add device ID 0x6639 to kernel btusb/btmtk + firmware section filtering
- **Not useful for WiFi**: BT uses USB/HCI, WiFi uses PCIe/WFDMA - completely separate paths
- Confirms: chip hardware is functional, WiFi-side initialization is the issue

---

## Architecture Quick Reference

### WFDMA DMA Ring Layout (HOST side, BAR0 offsets)
```
TX rings:  0xd4300 + qid*0x10  (BASE/CNT/CIDX/DIDX)
RX rings:  0xd4500 + qid*0x10
TX EXT:    0xd4600 + qid*4
RX EXT:    0xd4680 + qid*4
```

### MCU DMA0 Ring Layout (MCU side, BAR0 offsets)
```
MCU TX:    0x02300 + idx*0x10  (MCU→HOST, currently all BASE=0)
MCU RX:    0x02500 + idx*0x10  (HOST→MCU, RX2/RX3 configured by ROM)
MCU TX EXT: 0x02600 + idx*4
MCU RX EXT: 0x02680 + idx*4
```

### Command Flow (Working: HOST→MCU)
```
1. Build TXD in ring_wm descriptor (q15)
2. Write CIDX+1 to TX15 CIDX register (0xd43f8)
3. WFDMA DMAs descriptor+payload to MCU
4. MCU RX2 DIDX advances (command consumed)
```

### Response Flow (BROKEN: MCU→HOST)
```
1. MCU should write event to MCU_TX ring → DMA to HOST RX ring
2. HOST RX DIDX advances → driver reads event
3. PROBLEM: MCU_TX rings have BASE=0, so step 1 never happens
```
